<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Writing Tests &mdash; The Linux Kernel  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="_static/theme_rtd_colors.css" type="text/css" />
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Reference" href="api/index.html" />
    <link rel="prev" title="Run Tests without kunit_tool" href="run_manual.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> The Linux Kernel
          </a>
              <div class="version">
                6.1.0-rc5
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="start.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">KUnit Architecture</a></li>
<li class="toctree-l1"><a class="reference internal" href="run_wrapper.html">Running tests with kunit_tool</a></li>
<li class="toctree-l1"><a class="reference internal" href="run_manual.html">Run Tests without kunit_tool</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Writing Tests</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#test-cases">Test Cases</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#expectations">Expectations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assertions">Assertions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#test-suites">Test Suites</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#writing-tests-for-other-architectures">Writing Tests For Other Architectures</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#common-patterns">Common Patterns</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#isolating-behavior">Isolating Behavior</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#faking-classes">Faking Classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#testing-against-multiple-inputs">Testing Against Multiple Inputs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#parameterized-testing">Parameterized Testing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#exiting-early-on-failed-expectations">Exiting Early on Failed Expectations</a></li>
<li class="toctree-l2"><a class="reference internal" href="#allocating-memory">Allocating Memory</a></li>
<li class="toctree-l2"><a class="reference internal" href="#testing-static-functions">Testing Static Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="#injecting-test-only-code">Injecting Test-Only Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="#accessing-the-current-test">Accessing The Current Test</a></li>
<li class="toctree-l2"><a class="reference internal" href="#failing-the-current-test">Failing The Current Test</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="style.html">Test Style and Nomenclature</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="tips.html">Tips For Writing KUnit Tests</a></li>
<li class="toctree-l1"><a class="reference internal" href="running_tips.html">Tips For Running KUnit Tests</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">The Linux Kernel</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
      <li>Writing Tests</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/usage.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="writing-tests">
<h1>Writing Tests<a class="headerlink" href="#writing-tests" title="Permalink to this headline">¶</a></h1>
<section id="test-cases">
<h2>Test Cases<a class="headerlink" href="#test-cases" title="Permalink to this headline">¶</a></h2>
<p>The fundamental unit in KUnit is the test case. A test case is a function with
the signature <code class="docutils literal notranslate"><span class="pre">void</span> <span class="pre">(*)(struct</span> <span class="pre">kunit</span> <span class="pre">*test)</span></code>. It calls the function under test
and then sets <em>expectations</em> for what should happen. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">example_test_success</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">example_test_failure</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_FAIL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;This test never passes.&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">example_test_success</span></code> always passes because it does
nothing; no expectations are set, and therefore all expectations pass. On the
other hand <code class="docutils literal notranslate"><span class="pre">example_test_failure</span></code> always fails because it calls <code class="docutils literal notranslate"><span class="pre">KUNIT_FAIL</span></code>,
which is a special expectation that logs a message and causes the test case to
fail.</p>
<section id="expectations">
<h3>Expectations<a class="headerlink" href="#expectations" title="Permalink to this headline">¶</a></h3>
<p>An <em>expectation</em> specifies that we expect a piece of code to do something in a
test. An expectation is called like a function. A test is made by setting
expectations about the behavior of a piece of code under test. When one or more
expectations fail, the test case fails and information about the failure is
logged. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">add_test_basic</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In the above example, <code class="docutils literal notranslate"><span class="pre">add_test_basic</span></code> makes a number of assertions about the
behavior of a function called <code class="docutils literal notranslate"><span class="pre">add</span></code>. The first parameter is always of type
<code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span> <span class="pre">*</span></code>, which contains information about the current test context.
The second parameter, in this case, is what the value is expected to be. The
last value is what the value actually is. If <code class="docutils literal notranslate"><span class="pre">add</span></code> passes all of these
expectations, the test case, <code class="docutils literal notranslate"><span class="pre">add_test_basic</span></code> will pass; if any one of these
expectations fails, the test case will fail.</p>
<p>A test case <em>fails</em> when any expectation is violated; however, the test will
continue to run, and try other expectations until the test case ends or is
otherwise terminated. This is as opposed to <em>assertions</em> which are discussed
later.</p>
<p>To learn about more KUnit expectations, see Documentation/dev-tools/kunit/api/test.rst.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A single test case should be short, easy to understand, and focused on a
single behavior.</p>
</div>
<p>For example, if we want to rigorously test the <code class="docutils literal notranslate"><span class="pre">add</span></code> function above, create
additional tests cases which would test each property that an <code class="docutils literal notranslate"><span class="pre">add</span></code> function
should have as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">add_test_basic</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_negative</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_max</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">));</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">add_test_overflow</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MIN</span><span class="p">,</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">INT_MAX</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">));</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="assertions">
<h3>Assertions<a class="headerlink" href="#assertions" title="Permalink to this headline">¶</a></h3>
<p>An assertion is like an expectation, except that the assertion immediately
terminates the test case if the condition is not satisfied. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">test_sort</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kmalloc_array</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">725861</span><span class="p">)</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="mi">6599</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">),</span><span class="w"> </span><span class="n">cmpint</span><span class="p">,</span><span class="w"> </span><span class="nb">NULL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TEST_LEN</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"></span>
<span class="w">                </span><span class="n">KUNIT_EXPECT_LE</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="w"> </span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, the method under test should return pointer to a value. If the
pointer returns null or an errno, we want to stop the test since the following
expectation could crash the test case. <cite>ASSERT_NOT_ERR_OR_NULL(…)</cite> allows us
to bail out of the test case if the appropriate conditions are not satisfied to
complete the test.</p>
</section>
<section id="test-suites">
<h3>Test Suites<a class="headerlink" href="#test-suites" title="Permalink to this headline">¶</a></h3>
<p>We need many test cases covering all the unit’s behaviors. It is common to have
many similar tests. In order to reduce duplication in these closely related
tests, most unit testing frameworks (including KUnit) provide the concept of a
<em>test suite</em>. A test suite is a collection of test cases for a unit of code
with optional setup and teardown functions that run before/after the whole
suite and/or every test case. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_foo</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_bar</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_CASE</span><span class="p">(</span><span class="n">example_test_baz</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_suite</span><span class="w"> </span><span class="n">example_test_suite</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;example&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_init</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_exit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">suite_init</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_suite_init</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">suite_exit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_suite_exit</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">.</span><span class="n">test_cases</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">example_test_cases</span><span class="p">,</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="n">kunit_test_suite</span><span class="p">(</span><span class="n">example_test_suite</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>In the above example, the test suite <code class="docutils literal notranslate"><span class="pre">example_test_suite</span></code> would first run
<code class="docutils literal notranslate"><span class="pre">example_suite_init</span></code>, then run the test cases <code class="docutils literal notranslate"><span class="pre">example_test_foo</span></code>,
<code class="docutils literal notranslate"><span class="pre">example_test_bar</span></code>, and <code class="docutils literal notranslate"><span class="pre">example_test_baz</span></code>. Each would have
<code class="docutils literal notranslate"><span class="pre">example_test_init</span></code> called immediately before it and <code class="docutils literal notranslate"><span class="pre">example_test_exit</span></code>
called immediately after it. Finally, <code class="docutils literal notranslate"><span class="pre">example_suite_exit</span></code> would be called
after everything else. <code class="docutils literal notranslate"><span class="pre">kunit_test_suite(example_test_suite)</span></code> registers the
test suite with the KUnit test framework.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A test case will only run if it is associated with a test suite.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">kunit_test_suite(...)</span></code> is a macro which tells the linker to put the
specified test suite in a special linker section so that it can be run by KUnit
either after <code class="docutils literal notranslate"><span class="pre">late_init</span></code>, or when the test module is loaded (if the test was
built as a module).</p>
<p>For more information, see Documentation/dev-tools/kunit/api/test.rst.</p>
</section>
</section>
<section id="writing-tests-for-other-architectures">
<span id="kunit-on-non-uml"></span><h2>Writing Tests For Other Architectures<a class="headerlink" href="#writing-tests-for-other-architectures" title="Permalink to this headline">¶</a></h2>
<p>It is better to write tests that run on UML to tests that only run under a
particular architecture. It is better to write tests that run under QEMU or
another easy to obtain (and monetarily free) software environment to a specific
piece of hardware.</p>
<p>Nevertheless, there are still valid reasons to write a test that is architecture
or hardware specific. For example, we might want to test code that really
belongs in <code class="docutils literal notranslate"><span class="pre">arch/some-arch/*</span></code>. Even so, try to write the test so that it does
not depend on physical hardware. Some of our test cases may not need hardware,
only few tests actually require the hardware to test it. When hardware is not
available, instead of disabling tests, we can skip them.</p>
<p>Now that we have narrowed down exactly what bits are hardware specific, the
actual procedure for writing and running the tests is same as writing normal
KUnit tests.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>We may have to reset hardware state. If this is not possible, we may only
be able to run one test case per invocation.</p>
</div>
</section>
</section>
<section id="common-patterns">
<h1>Common Patterns<a class="headerlink" href="#common-patterns" title="Permalink to this headline">¶</a></h1>
<section id="isolating-behavior">
<h2>Isolating Behavior<a class="headerlink" href="#isolating-behavior" title="Permalink to this headline">¶</a></h2>
<p>Unit testing limits the amount of code under test to a single unit. It controls
what code gets run when the unit under test calls a function. Where a function
is exposed as part of an API such that the definition of that function can be
changed without affecting the rest of the code base. In the kernel, this comes
from two constructs: classes, which are structs that contain function pointers
provided by the implementer, and architecture-specific functions, which have
definitions selected at compile time.</p>
<section id="classes">
<h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<p>Classes are not a construct that is built into the C programming language;
however, it is an easily derived concept. Accordingly, in most cases, every
project that does not use a standardized object oriented library (like GNOME’s
GObject) has their own slightly different way of doing object oriented
programming; the Linux kernel is no exception.</p>
<p>The central concept in kernel object oriented programming is the class. In the
kernel, a <em>class</em> is a struct that contains function pointers. This creates a
contract between <em>implementers</em> and <em>users</em> since it forces them to use the
same function signature without having to call the function directly. To be a
class, the function pointers must specify that a pointer to the class, known as
a <em>class handle</em>, be one of the parameters. Thus the member functions (also
known as <em>methods</em>) have access to member variables (also known as <em>fields</em>)
allowing the same implementation to have multiple <em>instances</em>.</p>
<p>A class can be <em>overridden</em> by <em>child classes</em> by embedding the <em>parent class</em>
in the child class. Then when the child class <em>method</em> is called, the child
implementation knows that the pointer passed to it is of a parent contained
within the child. Thus, the child can compute the pointer to itself because the
pointer to the parent is always a fixed offset from the pointer to the child.
This offset is the offset of the parent contained in the child struct. For
example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">area</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">int</span><span class="w"> </span><span class="nf">rectangle_area</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">shape</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">rectangle_new</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">rectangle</span><span class="w"> </span><span class="o">*</span><span class="n">self</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">length</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">width</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">area</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rectangle_area</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">self</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, computing the pointer to the child from the pointer to the
parent is done by <code class="docutils literal notranslate"><span class="pre">container_of</span></code>.</p>
</section>
<section id="faking-classes">
<h3>Faking Classes<a class="headerlink" href="#faking-classes" title="Permalink to this headline">¶</a></h3>
<p>In order to unit test a piece of code that calls a method in a class, the
behavior of the method must be controllable, otherwise the test ceases to be a
unit test and becomes an integration test.</p>
<p>A fake class implements a piece of code that is different than what runs in a
production instance, but behaves identical from the standpoint of the callers.
This is done to replace a dependency that is hard to deal with, or is slow. For
example, implementing a fake EEPROM that stores the “contents” in an
internal buffer. Assume we have a class that represents an EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
<p>And we want to test code that buffers writes to the EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">ssize_t</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">flush</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="kt">size_t</span><span class="w"> </span><span class="n">flush_count</span><span class="p">;</span><span class="w"> </span><span class="cm">/* Flushes when buffer exceeds flush_count. */</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">new_eeprom_buffer</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom</span><span class="p">);</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">destroy_eeprom_buffer</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>We can test this code by <em>faking out</em> the underlying EEPROM:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="n">parent</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">contents</span><span class="p">[</span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="p">];</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="kt">ssize_t</span><span class="w"> </span><span class="nf">fake_eeprom_read</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">ssize_t</span><span class="w"> </span><span class="nf">fake_eeprom_write</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">count</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">container_of</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">offset</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">memcpy</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="n">count</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="kt">void</span><span class="w"> </span><span class="nf">fake_eeprom_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">this</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">read</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fake_eeprom_read</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">this</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">.</span><span class="n">write</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fake_eeprom_write</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">memset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">FAKE_EEPROM_CONTENTS_SIZE</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>We can now use it to test <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">eeprom_buffer</span></code>:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_does_not_write_until_flush</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIZE_MAX</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_flushes_after_flush_count_met</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_flushes_increments_of_flush_count</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer</span><span class="w"> </span><span class="o">*</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">fake_eeprom</span><span class="w"> </span><span class="o">*</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">buffer</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="mh">0xff</span><span class="p">,</span><span class="w"> </span><span class="mh">0xff</span><span class="p">};</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">flush_count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">eeprom_buffer</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span><span class="n">eeprom_buffer</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="mh">0xff</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Should have only flushed the first two bytes. */</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">contents</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">eeprom_buffer_test_init</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">),</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">fake_eeprom_init</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_eeprom_buffer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">fake_eeprom</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ctx</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">eeprom_buffer_test_exit</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">eeprom_buffer_test</span><span class="w"> </span><span class="o">*</span><span class="n">ctx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">destroy_eeprom_buffer</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">eeprom_buffer</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="testing-against-multiple-inputs">
<h2>Testing Against Multiple Inputs<a class="headerlink" href="#testing-against-multiple-inputs" title="Permalink to this headline">¶</a></h2>
<p>Testing just a few inputs is not enough to ensure that the code works correctly,
for example: testing a hash function.</p>
<p>We can write a helper macro or function. The function is called for each input.
For example, to test <code class="docutils literal notranslate"><span class="pre">sha1sum(1)</span></code>, we can write:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#define TEST_SHA1(in, want) \</span>
<span class="cp">        sha1sum(in, out); \</span>
<span class="cp">        KUNIT_EXPECT_STREQ_MSG(test, out, want, &quot;sha1sum(%s)&quot;, in);</span>

<span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span><span class="w"></span>
<span class="n">TEST_SHA1</span><span class="p">(</span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w">  </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">);</span><span class="w"></span>
<span class="n">TEST_SHA1</span><span class="p">(</span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">);</span><span class="w"></span>
</pre></div>
</div>
<p>Note the use of the <code class="docutils literal notranslate"><span class="pre">_MSG</span></code> version of <code class="docutils literal notranslate"><span class="pre">KUNIT_EXPECT_STREQ</span></code> to print a more
detailed error and make the assertions clearer within the helper macros.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">_MSG</span></code> variants are useful when the same expectation is called multiple
times (in a loop or helper function) and thus the line number is not enough to
identify what failed, as shown below.</p>
<p>In complicated cases, we recommend using a <em>table-driven test</em> compared to the
helper macro variation, for example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sha1</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="n">cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">cases</span><span class="p">);</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">sha1sum</span><span class="p">(</span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_STREQ_MSG</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sha1</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="s">&quot;sha1sum(%s)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>There is more boilerplate code involved, but it can:</p>
<ul class="simple">
<li><p>be more readable when there are multiple inputs/outputs (due to field names).</p>
<ul>
<li><p>For example, see <code class="docutils literal notranslate"><span class="pre">fs/ext4/inode-test.c</span></code>.</p></li>
</ul>
</li>
<li><p>reduce duplication if test cases are shared across multiple tests.</p>
<ul>
<li><p>For example: if we want to test <code class="docutils literal notranslate"><span class="pre">sha256sum</span></code>, we could add a <code class="docutils literal notranslate"><span class="pre">sha256</span></code>
field and reuse <code class="docutils literal notranslate"><span class="pre">cases</span></code>.</p></li>
</ul>
</li>
<li><p>be converted to a “parameterized test”.</p></li>
</ul>
<section id="parameterized-testing">
<h3>Parameterized Testing<a class="headerlink" href="#parameterized-testing" title="Permalink to this headline">¶</a></h3>
<p>The table-driven testing pattern is common enough that KUnit has special
support for it.</p>
<p>By reusing the same <code class="docutils literal notranslate"><span class="pre">cases</span></code> array from above, we can write the test as a
“parameterized test” with the following.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="c1">// This is copy-pasted from above.</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">sha1</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="n">cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;2aae6c35c94fcfb415dbe95f408b9ce91ee846ed&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="w">        </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello world!&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">                </span><span class="p">.</span><span class="n">sha1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;430ce34d020724ed75a196dfc2ad67c77772d169&quot;</span><span class="p">,</span><span class="w"></span>
<span class="w">        </span><span class="p">},</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="c1">// Need a helper function to generate a name for each test case.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">case_to_desc</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="o">*</span><span class="n">t</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">desc</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">strcpy</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="c1">// Creates `sha1_gen_params()` to iterate over `cases`.</span>
<span class="n">KUNIT_ARRAY_PARAM</span><span class="p">(</span><span class="n">sha1</span><span class="p">,</span><span class="w"> </span><span class="n">cases</span><span class="p">,</span><span class="w"> </span><span class="n">case_to_desc</span><span class="p">);</span><span class="w"></span>

<span class="c1">// Looks no different from a normal test.</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">sha1_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="c1">// This function can just contain the body of the for-loop.</span>
<span class="w">        </span><span class="c1">// The former `cases[i]` is accessible under test-&gt;param_value.</span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="n">out</span><span class="p">[</span><span class="mi">40</span><span class="p">];</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="o">*</span><span class="n">test_param</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">sha1_test_case</span><span class="w"> </span><span class="o">*</span><span class="p">)(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">param_value</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">sha1sum</span><span class="p">(</span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_STREQ_MSG</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">out</span><span class="p">,</span><span class="w"> </span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">sha1</span><span class="p">,</span><span class="w"></span>
<span class="w">                              </span><span class="s">&quot;sha1sum(%s)&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">test_param</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="c1">// Instead of KUNIT_CASE, we use KUNIT_CASE_PARAM and pass in the</span>
<span class="c1">// function declared by KUNIT_ARRAY_PARAM.</span>
<span class="k">static</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit_case</span><span class="w"> </span><span class="n">sha1_test_cases</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_CASE_PARAM</span><span class="p">(</span><span class="n">sha1_test</span><span class="p">,</span><span class="w"> </span><span class="n">sha1_gen_params</span><span class="p">),</span><span class="w"></span>
<span class="w">        </span><span class="p">{}</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>
</pre></div>
</div>
</section>
</section>
<section id="exiting-early-on-failed-expectations">
<h2>Exiting Early on Failed Expectations<a class="headerlink" href="#exiting-early-on-failed-expectations" title="Permalink to this headline">¶</a></h2>
<p>We can use <code class="docutils literal notranslate"><span class="pre">KUNIT_EXPECT_EQ</span></code> to mark the test as failed and continue
execution.  In some cases, it is unsafe to continue. We can use the
<code class="docutils literal notranslate"><span class="pre">KUNIT_ASSERT</span></code> variant to exit on failure.</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">example_test_user_alloc_function</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="o">*</span><span class="n">object</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">alloc_some_object_for_me</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Make sure we got a valid pointer back. */</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">object</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">do_something_with_object</span><span class="p">(</span><span class="n">object</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="allocating-memory">
<h2>Allocating Memory<a class="headerlink" href="#allocating-memory" title="Permalink to this headline">¶</a></h2>
<p>Where you might use <code class="docutils literal notranslate"><span class="pre">kzalloc</span></code>, you can instead use <code class="docutils literal notranslate"><span class="pre">kunit_kzalloc</span></code> as KUnit
will then ensure that the memory is freed once the test completes.</p>
<p>This is useful because it lets us use the <code class="docutils literal notranslate"><span class="pre">KUNIT_ASSERT_EQ</span></code> macros to exit
early from a test without having to worry about remembering to call <code class="docutils literal notranslate"><span class="pre">kfree</span></code>.
For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span><span class="w"> </span><span class="nf">example_test_allocation</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">buffer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">kunit_kzalloc</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="n">GFP_KERNEL</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Ensure allocation succeeded. */</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_ASSERT_NOT_ERR_OR_NULL</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="n">KUNIT_ASSERT_STREQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">buffer</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;&quot;</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
</section>
<section id="testing-static-functions">
<h2>Testing Static Functions<a class="headerlink" href="#testing-static-functions" title="Permalink to this headline">¶</a></h2>
<p>If we do not want to expose functions or variables for testing, one option is to
conditionally <code class="docutils literal notranslate"><span class="pre">#include</span></code> the test file at the end of your .c file. For
example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In my_file.c */</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">do_interesting_thing</span><span class="p">();</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MY_KUNIT_TEST</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;my_kunit_test.c&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
<section id="injecting-test-only-code">
<h2>Injecting Test-Only Code<a class="headerlink" href="#injecting-test-only-code" title="Permalink to this headline">¶</a></h2>
<p>Similar to as shown above, we can add test-specific logic. For example:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/* In my_file.h */</span><span class="w"></span>

<span class="cp">#ifdef CONFIG_MY_KUNIT_TEST</span>
<span class="cm">/* Defined in my_kunit_test.c */</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test_only_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span><span class="w"></span>
<span class="cp">#else</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">test_only_hook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>This test-only code can be made more useful by accessing the current <code class="docutils literal notranslate"><span class="pre">kunit_test</span></code>
as shown in next section: <em>Accessing The Current Test</em>.</p>
</section>
<section id="accessing-the-current-test">
<h2>Accessing The Current Test<a class="headerlink" href="#accessing-the-current-test" title="Permalink to this headline">¶</a></h2>
<p>In some cases, we need to call test-only code from outside the test file.
For example, see example in section <em>Injecting Test-Only Code</em> or if
we are providing a fake implementation of an ops struct. Using
<code class="docutils literal notranslate"><span class="pre">kunit_test</span></code> field in <code class="docutils literal notranslate"><span class="pre">task_struct</span></code>, we can access it via
<code class="docutils literal notranslate"><span class="pre">current-&gt;kunit_test</span></code>.</p>
<p>The example below includes how to implement “mocking”:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;linux/sched.h&gt;</span><span class="c1"> /* for current */</span><span class="cp"></span>

<span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">foo_result</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">want_foo_called_with</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">fake_foo</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">arg</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="o">-&gt;</span><span class="n">kunit_test</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="o">*</span><span class="n">test_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">want_foo_called_with</span><span class="p">,</span><span class="w"> </span><span class="n">arg</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">foo_result</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>

<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">example_simple_test</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">kunit</span><span class="w"> </span><span class="o">*</span><span class="n">test</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* Assume priv (private, a member used to pass test data from</span>
<span class="cm">         * the init function) is allocated in the suite&#39;s .init */</span><span class="w"></span>
<span class="w">        </span><span class="k">struct</span><span class="w"> </span><span class="nc">test_data</span><span class="w"> </span><span class="o">*</span><span class="n">test_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">test</span><span class="o">-&gt;</span><span class="n">priv</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">foo_result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">test_data</span><span class="o">-&gt;</span><span class="n">want_foo_called_with</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* In a real test, we&#39;d probably pass a pointer to fake_foo somewhere</span>
<span class="cm">         * like an ops struct, etc. instead of calling it directly. */</span><span class="w"></span>
<span class="w">        </span><span class="n">KUNIT_EXPECT_EQ</span><span class="p">(</span><span class="n">test</span><span class="p">,</span><span class="w"> </span><span class="n">fake_foo</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="mi">42</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</pre></div>
</div>
<p>In this example, we are using the <code class="docutils literal notranslate"><span class="pre">priv</span></code> member of <code class="docutils literal notranslate"><span class="pre">struct</span> <span class="pre">kunit</span></code> as a way
of passing data to the test from the init function. In general <code class="docutils literal notranslate"><span class="pre">priv</span></code> is
pointer that can be used for any user data. This is preferred over static
variables, as it avoids concurrency issues.</p>
<p>Had we wanted something more flexible, we could have used a named <code class="docutils literal notranslate"><span class="pre">kunit_resource</span></code>.
Each test can have multiple resources which have string names providing the same
flexibility as a <code class="docutils literal notranslate"><span class="pre">priv</span></code> member, but also, for example, allowing helper
functions to create resources without conflicting with each other. It is also
possible to define a clean up function for each resource, making it easy to
avoid resource leaks. For more information, see Documentation/dev-tools/kunit/api/test.rst.</p>
</section>
<section id="failing-the-current-test">
<h2>Failing The Current Test<a class="headerlink" href="#failing-the-current-test" title="Permalink to this headline">¶</a></h2>
<p>If we want to fail the current test, we can use <code class="docutils literal notranslate"><span class="pre">kunit_fail_current_test(fmt,</span> <span class="pre">args...)</span></code>
which is defined in <code class="docutils literal notranslate"><span class="pre">&lt;kunit/test-bug.h&gt;</span></code> and does not require pulling in <code class="docutils literal notranslate"><span class="pre">&lt;kunit/test.h&gt;</span></code>.
For example, we have an option to enable some extra debug checks on some data
structures as shown below:</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;kunit/test-bug.h&gt;</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_EXTRA_DEBUG_CHECKS</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">validate_my_data</span><span class="p">(</span><span class="k">struct</span><span class="w"> </span><span class="nc">data</span><span class="w"> </span><span class="o">*</span><span class="n">data</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">is_valid</span><span class="p">(</span><span class="n">data</span><span class="p">))</span><span class="w"></span>
<span class="w">                </span><span class="k">return</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="n">kunit_fail_current_test</span><span class="p">(</span><span class="s">&quot;data %p is invalid&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data</span><span class="p">);</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* Normal, non-KUnit, error reporting code here. */</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
<span class="cp">#else</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">my_debug_function</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="cp">#endif</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="run_manual.html" class="btn btn-neutral float-left" title="Run Tests without kunit_tool" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api/index.html" class="btn btn-neutral float-right" title="API Reference" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright The kernel development community.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>